# Exp4 银行家算法实验报告

## 🔬 实验目的

本实验旨在通过模拟银行家算法的动态资源分配和安全性检查过程，实现对操作系统中**死锁避免**机制的深入理解和验证。具体目的包括：

1.  掌握银行家算法中 **Max、Allocation、Need、Available** 四个核心数据结构的含义和计算关系。
2.  理解并应用**安全性检查算法**，判断系统在给定状态下是否存在一个安全序列。
3.  通过模拟动态资源请求，验证银行家算法如何有效**预防系统进入不安全状态**，从而避免死锁的发生。

## ⚙️ 实验内容

### 1. 初始环境设置

设定 5 个进程 $P_0$ 到 $P_4$，和 3 类资源 A、B、C。

| 矩阵/向量 | 设定值 | 描述 |
| :-------- | :----- | :--- |
| Available | $(3, 2, 2)$ | 系统当前可用资源。 |
| Max | 见表格 | 各进程最大需求。 |
| Allocation | 见表格 | 各进程初始已分配资源。（**已修改以确保初始安全**） |
| Need | **计算所得** | 各进程尚需资源 ($\text{Max} - \text{Allocation}$)。 |

| 进程 | Max (A, B, C) | Allocation (A, B, C) | Need (A, B, C) |
| :---: | :-------------: | :--------------------: | :--------------: |
| $P_0$ | (7, 5, 3) | (0, 3, 0) | (7, 2, 3) |
| $P_1$ | (3, 2, 2) | (2, 0, 0) | (1, 2, 2) |
| $P_2$ | (9, 0, 2) | (3, 0, 2) | (6, 0, 0) |
| $P_3$ | (2, 2, 2) | (2, 1, 1) | (0, 1, 1) |
| $P_4$ | (4, 3, 3) | (0, 0, 2) | (4, 3, 1) |

### 2. 安全性检查（初始状态）

执行安全性检查算法，查找一个安全序列来证明初始状态是安全的。

### 3. 动态资源请求模拟

模拟进程 $P_4$ 发起一个资源请求 $\text{Request}(P_4) = (1, 2, 0)$。

执行完整的资源分配流程：
* 检查请求的合法性（$\le \text{Need}$ 且 $\le \text{Available}$）。
* 进行**试分配**，更新 $\text{Available}$、$\text{Allocation}(P_4)$ 和 $\text{Need}(P_4)$。
* 对试分配后的新状态重新执行**安全性检查**。
* 根据安全性检查结果，做出最终的分配决策（接受或拒绝）。

## 📊 实验结果

<img width="866" height="618" alt="5de9efb907bca36cff9c473e50ee7b3d" src="https://github.com/user-attachments/assets/a675ec5b-2bc8-46d3-b9e7-b1dbcdac7972" />


### 1. 初始安全性检查结果

通过安全性检查，找到了安全序列：

$$\text{安全序列：}\quad \langle P_1, P_3, P_4, P_2, P_0 \rangle$$

**结论：** 初始系统处于**安全状态**。

### 2. 动态资源请求结果（$P_4$ 请求 $(1, 2, 0)$）

| 步骤 | 操作及状态 | 结果 |
| :---: | :--- | :--- |
| **合法性检查** | $\text{Request}(1, 2, 0) \le \text{Need}(4, 3, 1)$ 且 $\le \text{Available}(3, 2, 2)$ | **通过** |
| **试分配后的状态** | $\text{Available}=(2, 0, 2)$, $\text{Allocation}(P_4)=(1, 2, 2)$, $\text{Need}(P_4)=(3, 1, 1)$ | 状态更新 |
| **安全性检查** | 在 $\text{Work}=(2, 0, 2)$ 的新状态下查找满足 $\text{Need}_i \le \text{Work}$ 的进程。 | **失败** (找不到任何一个进程可以完成) |
| **最终决策** | 拒绝 $P_4$ 的资源请求。 | **$P_4$ 被阻塞，系统恢复到原始安全状态。** |

## 🔍 结果分析






###  Need 矩阵（尚需）



$$\text{Need} = \text{Max} - \text{Allocation}$$

| **进程** | **Max**   | **Allocation** | **Need**                           |
| -------- | --------- | -------------- | ---------------------------------- |
| $P_0$    | (7, 5, 3) | (0, **3**, 0)  | (7, **2**, 3) $\leftarrow$ (5-3=2) |
| $P_1$    | (3, 2, 2) | (2, 0, 0)      | (1, 2, 2)                          |
| $P_2$    | (9, 0, 2) | (3, 0, 2)      | (6, 0, 0)                          |
| $P_3$    | (2, 2, 2) | (2, 1, 1)      | (0, 1, 1)                          |
| $P_4$    | (4, 3, 3) | (0, 0, 2)      | (4, 3, 1)                          |

------



## 🚦 银行家算法（安全性检查）



**新初始状态：**

- **Work** $= (3, 2, 2)$
- **Finish** $= (\text{False}, \text{False}, \text{False}, \text{False}, \text{False})$



### 迭代过程



我们寻找一个安全序列 $\langle P_i, P_j, P_k, P_l, P_m \rangle$。

| **步骤** | **进程 Pi**    | **Need**  | **Work**   | **Need ≤ Work?** | **Work 向量更新**                       | **安全序列**                              |
| -------- | -------------- | --------- | ---------- | ---------------- | --------------------------------------- | ----------------------------------------- |
| 1.       | $P_1$          | (1, 2, 2) | (3, 2, 2)  | 满足 (Yes)       | (3, 2, 2) + **(2, 0, 0)** = (5, 2, 2)   | $\langle P_1 \rangle$                     |
| 2.       | $P_3$          | (0, 1, 1) | (5, 2, 2)  | 满足 (Yes)       | (5, 2, 2) + **(2, 1, 1)** = (7, 3, 3)   | $\langle P_1, P_3 \rangle$                |
| 3.       | $P_4$          | (4, 3, 1) | (7, 3, 3)  | 满足 (Yes)       | (7, 3, 3) + **(0, 0, 2)** = (7, 3, 5)   | $\langle P_1, P_3, P_4 \rangle$           |
| 4.       | $P_2$          | (6, 0, 0) | (7, 3, 5)  | 满足 (Yes)       | (7, 3, 5) + **(3, 0, 2)** = (10, 3, 7)  | $\langle P_1, P_3, P_4, P_2 \rangle$      |
| 5.       | $\mathbf{P_0}$ | (7, 2, 3) | (10, 3, 7) | **满足 (Yes)**   | (10, 3, 7) + **(0, 3, 0)** = (10, 6, 7) | $\langle P_1, P_3, P_4, P_2, P_0 \rangle$ |

**(检查 $P_0$ 的分配：** $(7, 2, 3) \le (10, 3, 7)$ $\rightarrow$ A: $7\le 10$, B: $2\le 3$, C: $3\le 7$)

------



## ✅ 最终结论



通过调整 $P_0$ 的已分配资源（从 $(0, 1, 0)$ 变为 $(0, 3, 0)$），系统成功进入安全状态。

**完整的安全序列为：**

$$\langle P_1, P_3, P_4, P_2, P_0 \rangle$$

由于找到了一个包含所有进程的安全序列，**系统处于安全状态**，可以保证所有进程最终都能完成，不会发生死锁。


### 1. 安全状态的维持

初始状态检查证明了即使资源被部分占用，系统仍存在一个执行顺序，可以保证所有进程都能在有限时间内完成，释放资源，从而避免死锁。这是银行家算法能够进行资源管理的前提。

### 2. 死锁避免的实现

当进程 $P_4$ 请求 $(1, 2, 0)$ 资源时：

* 从即时资源看，系统有足够资源 $(3, 2, 2)$ 来满足请求。
* 但是，**试分配后的新状态** $\text{Available}=(2, 0, 2)$ 无法满足任何一个进程 (如 $P_3$'s $\text{Need}=(0, 1, 1)$) 的需求。这意味着一旦分配，系统将进入一个**不安全状态**，未来可能导致死锁。

银行家算法的决策是**拒绝分配并阻塞 $P_4$**，从而成功地：

* **阻止**了系统从安全状态转移到不安全状态。
* **保证**了系统可以继续运行，等待 $P_4$ 或其他进程释放资源，直到 $P_4$ 的请求可以在安全状态下得到满足。

实验结果完美体现了银行家算法在操作系统中作为一种死锁**避免**机制的作用。
