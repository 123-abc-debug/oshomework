内存管理实施基于**分段**的内存管理策略，模拟**内存分配和释放过程**，观察和分析由此**产生的外部碎片**，并了解其根本原因。具体要求如下：
（1）用C/C++编写。
（2）随机模拟多个内存分配请求。
（3）对仿真结果进行深入分析。

Memory Management
Implement a memory management strategy based on Segmentation, simulate
memory allocation and deallocation processes, observe and analyze the resulting
external fragmentation, and understand its underlying causes. The specific
requirements are as follows:
(1) Write in C/C++. (2) Randomly simulate multiple memory allocation requests. (3) Conduct in-depth analysis of the simulation results..

# **实验报告：基于分段存储管理的内存分配与外部碎片模拟**

## **一、实验目的**

1. **理解分段存储管理的基本思想**
   掌握将程序按照逻辑结构划分为多个段，并在物理内存中独立存放的机制。

2. **掌握内存分配与释放过程**
   通过模拟多次随机内存分配与释放，了解段的动态装入和回收机制。

3. **观察外部碎片的形成过程**
   通过实验看到：段之间独立分配导致内存出现多个无法使用的小空洞，从而产生外部碎片。

4. **分析外部碎片产生的根本原因**
   了解为何**分段管理无法避免外部碎片**，以及碎片与段大小、分配策略、释放顺序的关系。

---

## **二、实验内容**

1. **采用 C++ 编写分段式内存管理模拟程序**
   使用数组模拟物理内存，每个分段随机大小，并采用连续分配方式。

2. **实现内存分配算法**

   * 首次适应算法（First Fit）
   * 为每次请求寻找合适的连续空闲区，以模拟段的装入。

3. **实现内存释放与空闲区合并**

   * 段被释放后，对其左右空闲区进行合并
   * 观察频繁分配和回收后内存空洞增多的情况。

4. **设置多次随机内存申请与释放**

   * 随机生成若干段大小（如 5–300KB）
   * 随机选择分配或释放
   * 记录每次操作后的空闲区分布和碎片数量。

5. **输出并可视化仿真过程**

   * 显示内存占用图（如 0/1 表示空闲/占用）
   * 显示空闲区数量、最大空闲区、碎片数等指标。

① 验证初始安全状态的判定逻辑；

② 测试合法资源请求的分配流程；

③ 模拟非法请求的过滤机制；

④ 验证请求后系统变不安全的回滚策略。实验以2个基础进程（P₀~P₁）、3类资源（A/B/C）为核心，延伸设计4类典型实验场景。


实现步骤
1.初始状态安全检查

输入初始状态

  
  Enter number of resource types: 3直接输“3”，按回车（代表3类资源A/B/C）Enter total amount of each resource (space separated): 10 5 7输“10 5 7”（中间用空格隔开），按回车（3类资源的总量）
  
  Enter number of processes: 2输“2”，按回车（代表2个进程P0、P1）
  
  Enter maximum demand for Process P0 (space separated): 7 5 3输“7 5 3”，按回车（P0对3类资源的最大需求）
  
  Enter maximum demand for Process P1 (space separated): 3 2 2输“3 2 2”，按回车（P1对3类资源的最大需求）
  
  Enter allocated resources for Process P0 (space separated): 0 1 0输“0 1 0”，按回车（初始分配给P0的资源）
  
  Enter allocated resources for Process P1 (space separated): 2 0 0输“2 0 0”，按回车（初始分配给P1的资源）



  合法资源请求
  Enter your choice (1 or 2): 1输“1”（选择“发起资源请求”），按回车
  
  Enter the process ID making the request: 1输“1”（代表请求的进程是P1），按回车（进程ID只能是0或1，因为只有2个进程）
  
  Enter requested resources for Process P1 (space separated): 1 0 2输“1 0 2”（P1请求1个A、0个B、2个C资源），按回车


非法资源请求

## **三、实验结果**

这份结果在程序逻辑上是完全正确的。内存的分配、释放和合并都按照预期工作，没有出现之前的内存布局错乱问题。这表明allocate函数的修正是成功的。
1. **随机分配和释放后内存迅速出现大量外部碎片**

   * 空闲区数量显著增加
   * 虽然空闲总量可能足够，但**无法找到连续区**分配新段。

2. **段大小波动越大，碎片产生越明显**
   大段/小段混合申请导致空闲区呈现“洞洞分布”，典型外部碎片特征。

3. **释放顺序影响碎片严重程度**

   * 若以与分配顺序完全一致的顺序释放，碎片少
   * 随机释放 → 外部碎片最严重

4. **外部碎片不可避免**
   分段管理本质是**可变大小连续分配**，必然产生外部碎片。

5. **实验验证了分段管理的不足**

   * 内存利用率下降
   * 分配失败率上升
   * 需要通过紧凑(compaction) 或分页机制来解决

---

实验内容（多场景拓展版，贴合实际操作与典型情况）

一、实验核心目标与场景设计

本实验以银行家算法为核心，通过“基础场景+异常场景”的组合设计，完整验证死锁避免机制的有效性。核心目标包括：① 验证初始安全状态的判定逻辑；② 测试合法资源请求的分配流程；③ 模拟非法请求的过滤机制；④ 验证请求后系统变不安全的回滚策略。实验以2个基础进程（P₀~P₁）、3类资源（A/B/C）为核心，延伸设计4类典型实验场景。

二、统一实验环境配置

为保证场景对比的有效性，所有实验场景基于统一的初始资源配置（除特殊说明外），具体如下：

配置项

具体内容

说明

进程数量

2个（P₀、P₁）

模拟并发执行的基础进程单元

资源类型

3类（A、B、C）

分别对应CPU、内存、I/O设备资源

总资源向量（Total）

(10, 5, 7)

系统中每类资源的物理总量

Max矩阵（最大需求）

P₀: (7,5,3)；P₁: (3,2,2)

进程运行全程对各类资源的最大需求上限

基础Allocation矩阵（初始分配）

P₀: (0,1,0)；P₁: (2,0,0)

系统启动时已分配给进程的资源量

基础Need矩阵（剩余需求）

P₀: (7,4,3)；P₁: (1,2,2)

Need = Max - Allocation，即进程还需的资源量

基础Available向量（可用资源）

(8,4,7)

Available = Total - 所有进程Allocation之和

三、分场景实验过程与结果

场景1：初始状态安全检查（基础验证）

实验目的：验证银行家算法的安全序列生成逻辑，确认初始状态是否具备无死锁条件。

1. 操作时机：编译运行程序后，首先进入“System Initialization（系统初始化）”阶段，按提示逐行输入以下内容。

2. 逐行输入内容（带屏幕提示对应）：
  屏幕出现的提示文字你需要输入的内容输入说明（小白必看）Enter number of resource types: 3直接输“3”，按回车（代表3类资源A/B/C）Enter total amount of each resource (space separated): 10 5 7输“10 5 7”（中间用空格隔开），按回车（3类资源的总量）Enter number of processes: 2输“2”，按回车（代表2个进程P0、P1）Enter maximum demand for Process P0 (space separated): 7 5 3输“7 5 3”，按回车（P0对3类资源的最大需求）Enter maximum demand for Process P1 (space separated): 3 2 2输7“3 2 2”，按回车（P1对3类资源的最大需求）Enter allocated resources for Process P0 (space separated): 0 1 0输“0 1 0”，按回车（初始分配给P0的资源）Enter allocated resources for Process P1 (space separated): 2 0 0输“2 0 0”，按回车（初始分配给P1的资源）

3. 等待程序自动执行：输入完成后，程序会自动计算Need、Available矩阵，并执行安全检查，无需你操作。

4. 查看实验结果：程序会输出“Initial system state is safe. Safe sequence: P0 P1 ”，代表初始状态安全，场景1完成。

5. 小白注意事项：
  输入时只输数字和空格，不要加括号（比如输“10 5 7”不是“(10,5,7)”）；

6. 如果输错（比如多输一个数字），程序会提示“Invalid input”，按提示重新输入即可。

场景2：合法资源请求（正常分配流程）

实验目的：模拟符合规则的资源请求，验证“合法性校验→试探分配→安全检查→正式分配”的完整流程。

1. 操作时机：场景1完成后，屏幕会出现“Menu”菜单，此时进入场景2的资源请求流程。

2. 逐行输入内容（带屏幕提示对应）：
  屏幕出现的提示文字你需要输入的内容输入说明（小白必看）===== Menu =====
1. Make a resource request
2. Exit
Enter your choice (1 or 2): 1输“1”（选择“发起资源请求”），按回车Enter the process ID making the request: 1输“1”（代表请求的进程是P1），按回车（进程ID只能是0或1，因为只有2个进程）Enter requested resources for Process P1 (space separated): 1 0 2输“1 0 2”（P1请求1个A、0个B、2个C资源），按回车

3. 等待程序自动执行：输入完成后，程序会自动做3件事：① 校验请求是否合法；② 试探分配资源；③ 检查新状态是否安全，无需你操作。

4. 查看实验结果：程序会输出以下内容，代表分配成功：
  System is safe after allocation.

5. Safe sequence: P0 P1 

6. Updated Available: 7 4 5 

7. 后续操作：分配完成后，屏幕会再次出现“Menu”菜单，此时可选择“2”退出，或继续其他场景。

8. 小白注意事项：
  进程ID不能乱输（比如输“2”会提示“Invalid input”），只能是0或1；

9. 请求资源数必须是3个（对应3类资源），少输或多输都会被提示重新输入。

场景3：非法资源请求（过滤机制验证）

实验目的：模拟两类典型非法请求，验证算法对无效请求的过滤能力，避免系统状态混乱。

子场景3.1：请求超过进程剩余需求

- 操作时机：重新编译运行程序，完成场景1的初始化输入后，当屏幕出现“Menu”菜单时，开始此场景。

- 逐行输入内容（带屏幕提示对应）：
  屏幕出现的提示文字你需要输入的内容输入说明（小白必看）===== Menu =====
1. Make a resource request
2. Exit
Enter your choice (1 or 2): 1输“1”，按回车（选择发起请求）Enter the process ID making the request: 1输“1”（请求进程为P1），按回车Enter requested resources for Process P1 (space separated): 2 0 2输“2 0 2”（故意让A类资源请求超需求），按回车

- 查看实验结果：程序会立即提示“Request exceeds the remaining need. Request denied.”，代表请求被拒绝，不执行分配。

- 小白为什么会拒绝？：P1的A类资源剩余需求是1（Need矩阵里P1的A是1），但你请求2，超过了“最大需要”，所以非法。

- 核心意义：防止进程请求超出自身最大需求，避免资源请求的逻辑矛盾。

子场景3.2：请求超过系统可用资源

- 操作时机：有两种方式触发：① 完成场景2（P1已分配资源后）发起请求；② 初始化后直接发起（需用大请求数），这里推荐方式①，步骤更清晰。

- 前置步骤：先按场景2的步骤，让P1成功分配资源（此时Available更新为7 4 5），屏幕再次出现“Menu”菜单。

- 逐行输入内容（带屏幕提示对应）：
  屏幕出现的提示文字你需要输入的内容输入说明（小白必看）===== Menu =====
1. Make a resource request
2. Exit
Enter your choice (1 or 2): 1输“1”，按回车Enter the process ID making the request: 0输“0”（请求进程为P0），按回车Enter requested resources for Process P0 (space separated): 9 0 0输“9 0 0”（A类资源请求9，超过当前可用的7），按回车

- 查看实验结果：程序提示“Resources unavailable. Process blocked.”，代表P0被阻塞，请求被拒绝。

- 小白为什么会阻塞？：系统当前只有7个A类资源可用，但P0要9个，资源不够，只能让P0等着，直到其他进程释放资源。

- 核心意义：避免可用资源耗尽导致的系统瘫痪，通过阻塞机制协调资源供需。

场景4：请求后系统变不安全（回滚机制验证）

实验目的：模拟“请求合法但分配后不安全”的临界场景，验证算法的回滚策略，从源头避免死锁。

1. 操作准备：此场景需要修改“初始分配矩阵”，所以编译运行程序后，在初始化阶段就输入新的分配数据，不要用默认的初始配置。

2. 第一步：特殊初始化输入（关键！）：按以下内容完成初始化，和场景1的输入只有P0的分配资源不同：
  屏幕提示文字你输入的内容小白说明Enter number of resource types: 3和场景1一样Enter total amount of each resource (space separated): 10 5 7和场景1一样Enter number of processes: 2和场景1一样Enter maximum demand for Process P0 (space separated): 7 5 3和场景1一样Enter maximum demand for Process P1 (space separated): 3 2 2和场景1一样Enter allocated resources for Process P0 (space separated): 1 1 0这里和场景1不同！输“1 1 0”Enter allocated resources for Process P1 (space separated): 2 0 0和场景1一样输入完成后，程序会提示初始状态安全（安全序列还是P0→P1），进入“Menu”菜单。

3. 第二步：先让P1发起请求（和场景2一样）：
  屏幕提示输入内容Enter your choice (1 or 2): 1Enter the process ID making the request: 1Enter requested resources for Process P1 (space separated): 1 0 2此时P1请求成功，Available更新为(7-1,4-0,7-2)=(6,4,5)。

4. 第三步：让P0发起临界请求（关键操作）：屏幕再次出现“Menu”菜单，继续输入：
  屏幕提示输入内容Enter your choice (1 or 2): 1Enter the process ID making the request: 0Enter requested resources for Process P0 (space separated): 6 4 3

5. 等待程序自动执行：程序会先判断请求合法（6≤6、4≤4、3≤3；且6≤6、4≤4、3≤5），然后执行试探分配，再检查安全状态。

6. 查看实验结果：程序提示“System would be unsafe! Request denied, state rolled back.”，代表请求被拒绝，系统恢复到请求前的状态。

7. 小白为什么会回滚？：虽然P0的请求合法，但分配后系统没有安全序列了（P1需要2个B资源，但可用资源只有0个），可能死锁，所以程序“反悔”了，把资源退回去。

8. 回滚效果：Available还是(6,4,5)，P0的Need还是(6,4,3)，和请求前一样。

9. 核心意义：通过“试探-检查-回滚”机制，即使请求合法，也会因可能导致死锁而拒绝，是死锁避免的核心保障。





四、实验关键数据记录要求

为支撑后续结果分析，每类场景需记录以下数据，形成对比表格：

- 基础数据记录（小白直接填下表）：
  场景操作类型请求进程ID请求资源量（A,B,C）1安全检查无无2资源分配1(1,0,2)3.1资源分配1(2,0,2)3.2资源分配0(9,0,0)4资源分配0(6,4,3)

- 状态数据记录（小白对照程序输出填）：以场景2为例，其他场景按此格式记录：
  场景操作前Available操作后Available涉及进程的Allocation（操作后）涉及进程的Need（操作后）2(8,4,7)(7,4,5)P1: (3,0,2)P1: (0,2,0)3.1(8,4,7)无（未分配）P1: (2,0,0)（不变）P1: (1,2,2)（不变）

- 结果数据记录（小白直接抄程序提示）：
  场景安全序列（若有）操作结果死锁风险1P0,P1初始状态安全无2P0,P1分配成功无3.1无请求拒绝无（未分配）3.2无进程阻塞无（阻塞而非死锁）4无请求拒绝，系统回滚有（回滚后消除）

- 小白记录技巧：程序输出的内容可以用“复制粘贴”（终端里选中就是复制，右键是粘贴）到文档里，避免手动输入出错。


## 实验数据说明
<img width="808" height="803" alt="ef048e3b9f86e0a7071c22809e88d8e0" src="https://github.com/user-attachments/assets/14899079-8d04-4e0e-9cb9-e70486a892ba" />

## 一、实验数据概述
本次实验通过修正后的分段内存管理模拟程序，完成了20次随机内存操作（分配概率70%、释放概率30%），模拟了5个并发进程对内存的动态需求。实验核心数据如下：
- 物理内存总大小：1024 KB
- 分配请求大小范围：36 KB ~ 109 KB（最小分配请求36 KB）
- 总操作次数：20次（分配成功12次、释放成功5次、释放失败3次）
- 最终内存状态：4个空闲块（大小分别为36 KB、48 KB、41 KB、349 KB），无外部碎片
- 最终外部碎片率：0.0%

## 二、实验数据详细解读
### 1. 内存操作与布局演变分析
#### （1）初始阶段（请求1-6）
- 请求1为释放操作（进程5的段2），因未分配过该段导致释放失败，内存保持初始空闲状态（1024 KB连续空闲块）。
- 请求2-3成功分配进程3（36 KB）和进程2（91 KB）的段，内存布局变为“已分配块+空闲块”的连续结构：
  - 起始地址0 KB（36 KB，已分配）→ 36 KB（91 KB，已分配）→ 127 KB（897 KB，空闲），体现了首次适应算法“顺序查找、连续分配”的核心特征。
- 请求4释放进程3的段1后，内存出现首个空闲块（0 KB，36 KB），但因与后续已分配块（36 KB，91 KB）不相邻，未触发空闲块合并，此时内存布局开始呈现“空闲块-已分配块-空闲块”的碎片化趋势雏形。

#### （2）中期阶段（请求7-17）
- 请求7-9、11、14-18共8次分配操作均成功，进程5、4、2、3的多个段被连续分配到高地址空闲区，内存布局逐渐细化为多块已分配块与空闲块交替的结构：
  - 例如请求15分配进程3的段1（61 KB）时，程序通过首次适应算法找到地址212 KB的空闲块（原102 KB），拆分后形成“61 KB已分配块+41 KB空闲块”，符合“按需分配、剩余拆分”的逻辑。
- 请求12-13两次释放进程5的段0，成功将对应的已分配块标记为空闲，并因相邻块均为已分配块，未触发合并，此时内存出现分散的空闲块（127 KB，48 KB；212 KB，102 KB），但块大小均大于最小分配请求（36 KB），未形成碎片。

#### （3）最终阶段（请求19-20）
- 请求19释放操作失败（进程5的段0已释放），请求20成功释放进程4的段0（37 KB），并触发相邻空闲块合并：
  - 原地址164 KB的11 KB空闲块与刚释放的175 KB（37 KB）空闲块合并为48 KB空闲块，最终形成4个连续且大小充足的空闲块，所有空闲块尺寸均≥36 KB（最小分配请求）。

### 2. 关键指标数据解读
#### （1）外部碎片率（0.0%）
- 数据含义：外部碎片率是指“小于最小分配请求的空闲块总大小”占总内存的比例。本次实验中，所有空闲块（36 KB、48 KB、41 KB、349 KB）均大于或等于最小分配请求（36 KB），因此碎片率为0%。
- 核心逻辑：碎片的定义是“无法满足任何分配请求的空闲块”，本次实验的空闲块均具备分配能力，故无有效碎片产生。

#### （2）分配成功率（100%）
- 数据含义：12次分配请求全部成功，无因内存不足或碎片过多导致的分配失败。
- 原因分析：一方面，总空闲内存（36+48+41+349=474 KB）仍充足；另一方面，空闲块大小均能满足所有历史分配请求的尺寸需求，未出现“总空闲内存充足但无连续块可用”的情况。

#### （3）释放失败情况（3次）
- 数据含义：3次释放失败均因“请求释放的段未被分配过”（如进程5的段2、进程4的段0）。
- 说明：模拟中释放操作是随机生成的，未考虑进程的实际分配历史，符合真实系统中“无效释放请求”的场景，验证了程序对非法释放的容错处理能力。

## 三、实验数据说明的核心问题
### 1. 分段内存管理的核心优势得到验证
#### （1）连续分配与逻辑独立性保障
实验中所有段的分配均为连续物理内存块（如进程2的段1、段2分别分配在36 KB和314 KB起始地址，均为连续块），体现了分段管理“按逻辑模块分配连续内存”的设计思想，保障了进程运行时的地址访问效率。

#### （2）空闲块合并机制有效减少碎片
请求4、12、13、20的释放操作后，程序均自动合并相邻空闲块（如请求20将11 KB和37 KB空闲块合并为48 KB），验证了空闲块合并机制的有效性——该机制能避免因频繁释放产生的微小空闲块累积，是缓解外部碎片的关键手段。

### 2. 外部碎片的产生与分配算法的关联性
#### （1）碎片产生的前提条件未满足
本次实验碎片率为0%的核心原因：
- 分配请求大小差异较小（36 KB ~ 109 KB），无极端大小的段请求，减少了“大段分配后残留小空闲块”的概率；
- 最小分配请求（36 KB）与最终空闲块大小（均≥36 KB）匹配，无“无法满足最小请求”的空闲块；
- 释放操作触发的合并机制及时整合了分散空闲块，避免了碎片累积。

#### （2）首次适应算法的表现特征
实验数据表明，首次适应算法在“分配请求大小均匀、操作频率适中”的场景下表现优异：
- 优势：查找效率高，优先利用低地址空闲块，高地址保留大块空闲区（如最终349 KB空闲块），便于后续大段分配；
- 局限性：若长期频繁分配小尺寸段，低地址区域可能形成大量小空闲块（本次实验未出现该情况），需依赖合并机制优化。

### 3. 分段管理的适用场景与局限性启示
#### （1）适用场景验证
实验数据说明，分段内存管理适用于“进程段大小相对均匀、分配/释放频率适中”的场景，能通过连续分配保障访问效率，通过合并机制控制碎片。

#### （2）潜在局限性暗示
本次实验的“零碎片”结果具有特殊性，未模拟极端场景：
- 若分配请求大小差异极大（如5 KB ~ 300 KB），可能产生大量小于最小请求的空闲块，导致碎片率上升；
- 若长期不释放大块内存，可能出现“总空闲内存充足但无连续块满足大段请求”的情况（即外部碎片的核心问题），需通过内存紧凑或段页式管理优化。

## 四、实验结论
1. 修正后的模拟程序准确实现了分段内存管理的核心功能，内存分配、释放及空闲块合并逻辑正确，实验数据真实反映了动态内存操作下的内存状态演变。
2. 分段管理的“连续分配+空闲块合并”机制能有效控制外部碎片，在合理的请求模式下可实现零碎片运行，验证了该管理方式的可行性。
3. 外部碎片的产生与分配请求大小分布、操作频率密切相关，首次适应算法在均匀请求场景下表现最优，但需警惕极端场景下的碎片累积问题。
4. 实验结果为理解分段内存管理的优缺点提供了数据支撑：其优势在于逻辑独立性强、访问效率高，局限性在于对请求模式敏感，易产生外部碎片，需结合内存紧凑或段页式混合管理方案优化。


# 实验展示的数据
内存初始化完成，总大小：1024 KB

【请求1】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：1024 KB | 状态：空闲
==================================================

【请求2】分配 - 进程3 | 段1 | 大小36 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：36 KB | 大小：988 KB | 状态：空闲
==================================================

【请求3】分配 - 进程2 | 段1 | 大小91 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求4】释放 - 进程3 | 段1
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求5】释放 - 进程4 | 段0
释放失败：未找到进程4的段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求6】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求7】分配 - 进程5 | 段0 | 大小48 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：849 KB | 状态：空闲
==================================================

【请求8】分配 - 进程4 | 段0 | 大小37 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：812 KB | 状态：空闲
==================================================

【请求9】分配 - 进程5 | 段0 | 大小102 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：710 KB | 状态：空闲
==================================================

【请求10】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：710 KB | 状态：空闲
==================================================

【请求11】分配 - 进程2 | 段2 | 大小108 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求12】释放 - 进程5 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求13】释放 - 进程5 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求14】分配 - 进程3 | 段0 | 大小109 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：493 KB | 状态：空闲
==================================================

【请求15】分配 - 进程3 | 段1 | 大小61 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：493 KB | 状态：空闲
==================================================

【请求16】分配 - 进程2 | 段2 | 大小85 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：408 KB | 状态：空闲
==================================================

【请求17】分配 - 进程4 | 段2 | 大小59 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求18】分配 - 进程4 | 段1 | 大小37 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：11 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求19】释放 - 进程5 | 段0
释放失败：未找到进程5的段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：11 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求20】释放 - 进程4 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：48 KB | 状态：空闲
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

==================== 模拟结果分析 ====================
总内存大小：1024 KB
外部碎片率：0%
======================================================



# 实验代码

#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <algorithm>

using namespace std;

// 内存块结构体
struct Block {
    int start;
    int size;
    int process_id;
    int segment_id;
};

vector<Block> memory;
const int MEMORY_SIZE = 1024;
const int NUM_REQUESTS = 20;

// 初始化内存
void initialize_memory() {
    memory.clear();
    memory.push_back({0, MEMORY_SIZE, -1, -1});
    cout << "内存初始化完成，总大小：" << MEMORY_SIZE << " KB\n" << endl;
}
// 内存分配（首次适应算法）- 修正版
bool allocate(int process_id, int segment_id, int size) {
    for (int i = 0; i < memory.size(); i++) {
        // 直接使用索引访问，而不是创建引用
        if (memory[i].process_id == -1 && memory[i].size >= size) {
            // 先保存要分配的块的起始地址，因为后面可能会插入新块
            int start_address = memory[i].start;

            // 如果空闲块大于需求，拆分
            if (memory[i].size > size) {
                // 在当前块后面插入一个新的空闲块
                memory.insert(memory.begin() + i + 1,
                    {start_address + size, memory[i].size - size, -1, -1});
            }

            // 关键修正：通过索引重新访问并修改块，而不是使用引用
            memory[i].size = size;
            memory[i].process_id = process_id;
            memory[i].segment_id = segment_id;

            return true;
        }
    }
    return false; // 分配失败
}

// 合并相邻空闲块
void merge_free_blocks() {
    for (int i = 0; i < (int)memory.size() - 1; ) {
        if (memory[i].process_id == -1 && memory[i+1].process_id == -1) {
            memory[i].size += memory[i+1].size;
            memory.erase(memory.begin() + i + 1);
        } else {
            i++;
        }
    }
}

// 释放内存块
void deallocate(int process_id, int segment_id) {
    for (int i = 0; i < memory.size(); i++) {
        Block &block = memory[i];

        if (block.process_id == process_id && block.segment_id == segment_id) {
            block.process_id = -1;
            block.segment_id = -1;

            // 合并空闲块
            merge_free_blocks();
            return;
        }
    }

    cout << "释放失败：未找到进程" << process_id << "的段" << segment_id << "\n";
}

// 计算外部碎片率
double calculate_external_fragmentation(const vector<int>& allocation_sizes) {
    if (allocation_sizes.empty()) return 0.0;

    int smallest_request = *min_element(allocation_sizes.begin(), allocation_sizes.end());
    int fragmented_memory = 0;

    for (const auto& block : memory) {
        if (block.process_id == -1 && block.size < smallest_request) {
            fragmented_memory += block.size;
        }
    }

    return (double)fragmented_memory / MEMORY_SIZE * 100.0;
}

// 打印内存布局
void print_memory_layout() {
    cout << "==================== 内存布局 ====================\n";
    for (const auto& block : memory) {
        cout << "起始地址：" << block.start << " KB | 大小：" << block.size << " KB | ";
        if (block.process_id == -1) {
            cout << "状态：空闲\n";
        } else {
            cout << "状态：已分配 | 进程ID：" << block.process_id
                 << " | 段ID：" << block.segment_id << "\n";
        }
    }
    cout << "==================================================\n\n";
}

int main() {
    srand(time(0));
    initialize_memory();

    vector<int> allocation_sizes;

    for (int i = 0; i < NUM_REQUESTS; ++i) {
        int process_id = rand() % 5 + 1;
        int segment_id = rand() % 3;
        int size = rand() % 100 + 10;

        allocation_sizes.push_back(size);

        if (rand() % 10 < 7) {
            cout << "【请求" << i+1 << "】分配 - 进程" << process_id
                 << " | 段" << segment_id << " | 大小" << size << " KB\n";

            if (allocate(process_id, segment_id, size)) {
                cout << "分配成功！\n";
            } else {
                cout << "分配失败！无足够大的空闲块\n";
            }
        } else {
            cout << "【请求" << i+1 << "】释放 - 进程" << process_id
                 << " | 段" << segment_id << "\n";

            deallocate(process_id, segment_id);
            cout << "释放操作完成\n";
        }

        print_memory_layout();
    }

    double fragmentation_rate = calculate_external_fragmentation(allocation_sizes);
    cout << "==================== 模拟结果分析 ====================\n";
    cout << "总内存大小：" << MEMORY_SIZE << " KB\n";
    cout << "外部碎片率：" << fragmentation_rate << "%\n";
    cout << "======================================================\n";

    return 0;
}



