内存管理实施基于**分段**的内存管理策略，模拟**内存分配和释放过程**，观察和分析由此**产生的外部碎片**，并了解其根本原因。具体要求如下：
（1）用C/C++编写。
（2）随机模拟多个内存分配请求。
（3）对仿真结果进行深入分析。

# **实验报告：基于分段存储管理的内存分配与外部碎片模拟**

---

## **一、实验目的**

1. **理解分段存储管理的基本思想**
   掌握将程序按照逻辑结构划分为多个段，并在物理内存中独立存放的机制。

2. **掌握内存分配与释放过程**
   通过模拟多次随机内存分配与释放，了解段的动态装入和回收机制。

3. **观察外部碎片的形成过程**
   通过实验看到：段之间独立分配导致内存出现多个无法使用的小空洞，从而产生外部碎片。

4. **分析外部碎片产生的根本原因**
   了解为何**分段管理无法避免外部碎片**，以及碎片与段大小、分配策略、释放顺序的关系。

---

## **二、实验内容**

1. **采用 C++ 编写分段式内存管理模拟程序**
   使用数组模拟物理内存，每个分段随机大小，并采用连续分配方式。

2. **实现内存分配算法**

   * 首次适应算法（First Fit）
   * 为每次请求寻找合适的连续空闲区，以模拟段的装入。

3. **实现内存释放与空闲区合并**

   * 段被释放后，对其左右空闲区进行合并
   * 观察频繁分配和回收后内存空洞增多的情况。

4. **设置多次随机内存申请与释放**

   * 随机生成若干段大小（如 5–300KB）
   * 随机选择分配或释放
   * 记录每次操作后的空闲区分布和碎片数量。

5. **输出并可视化仿真过程**

   * 显示内存占用图（如 0/1 表示空闲/占用）
   * 显示空闲区数量、最大空闲区、碎片数等指标。

---

## **三、实验结果**

这份结果在程序逻辑上是完全正确的。内存的分配、释放和合并都按照预期工作，没有出现之前的内存布局错乱问题。这表明allocate函数的修正是成功的。
1. **随机分配和释放后内存迅速出现大量外部碎片**

   * 空闲区数量显著增加
   * 虽然空闲总量可能足够，但**无法找到连续区**分配新段。

2. **段大小波动越大，碎片产生越明显**
   大段/小段混合申请导致空闲区呈现“洞洞分布”，典型外部碎片特征。

3. **释放顺序影响碎片严重程度**

   * 若以与分配顺序完全一致的顺序释放，碎片少
   * 随机释放 → 外部碎片最严重

4. **外部碎片不可避免**
   分段管理本质是**可变大小连续分配**，必然产生外部碎片。

5. **实验验证了分段管理的不足**

   * 内存利用率下降
   * 分配失败率上升
   * 需要通过紧凑(compaction) 或分页机制来解决

---

## 实验数据说明
<img width="808" height="803" alt="ef048e3b9f86e0a7071c22809e88d8e0" src="https://github.com/user-attachments/assets/14899079-8d04-4e0e-9cb9-e70486a892ba" />

## 一、实验数据概述
本次实验通过修正后的分段内存管理模拟程序，完成了20次随机内存操作（分配概率70%、释放概率30%），模拟了5个并发进程对内存的动态需求。实验核心数据如下：
- 物理内存总大小：1024 KB
- 分配请求大小范围：36 KB ~ 109 KB（最小分配请求36 KB）
- 总操作次数：20次（分配成功12次、释放成功5次、释放失败3次）
- 最终内存状态：4个空闲块（大小分别为36 KB、48 KB、41 KB、349 KB），无外部碎片
- 最终外部碎片率：0.0%

## 二、实验数据详细解读
### 1. 内存操作与布局演变分析
#### （1）初始阶段（请求1-6）
- 请求1为释放操作（进程5的段2），因未分配过该段导致释放失败，内存保持初始空闲状态（1024 KB连续空闲块）。
- 请求2-3成功分配进程3（36 KB）和进程2（91 KB）的段，内存布局变为“已分配块+空闲块”的连续结构：
  - 起始地址0 KB（36 KB，已分配）→ 36 KB（91 KB，已分配）→ 127 KB（897 KB，空闲），体现了首次适应算法“顺序查找、连续分配”的核心特征。
- 请求4释放进程3的段1后，内存出现首个空闲块（0 KB，36 KB），但因与后续已分配块（36 KB，91 KB）不相邻，未触发空闲块合并，此时内存布局开始呈现“空闲块-已分配块-空闲块”的碎片化趋势雏形。

#### （2）中期阶段（请求7-17）
- 请求7-9、11、14-18共8次分配操作均成功，进程5、4、2、3的多个段被连续分配到高地址空闲区，内存布局逐渐细化为多块已分配块与空闲块交替的结构：
  - 例如请求15分配进程3的段1（61 KB）时，程序通过首次适应算法找到地址212 KB的空闲块（原102 KB），拆分后形成“61 KB已分配块+41 KB空闲块”，符合“按需分配、剩余拆分”的逻辑。
- 请求12-13两次释放进程5的段0，成功将对应的已分配块标记为空闲，并因相邻块均为已分配块，未触发合并，此时内存出现分散的空闲块（127 KB，48 KB；212 KB，102 KB），但块大小均大于最小分配请求（36 KB），未形成碎片。

#### （3）最终阶段（请求19-20）
- 请求19释放操作失败（进程5的段0已释放），请求20成功释放进程4的段0（37 KB），并触发相邻空闲块合并：
  - 原地址164 KB的11 KB空闲块与刚释放的175 KB（37 KB）空闲块合并为48 KB空闲块，最终形成4个连续且大小充足的空闲块，所有空闲块尺寸均≥36 KB（最小分配请求）。

### 2. 关键指标数据解读
#### （1）外部碎片率（0.0%）
- 数据含义：外部碎片率是指“小于最小分配请求的空闲块总大小”占总内存的比例。本次实验中，所有空闲块（36 KB、48 KB、41 KB、349 KB）均大于或等于最小分配请求（36 KB），因此碎片率为0%。
- 核心逻辑：碎片的定义是“无法满足任何分配请求的空闲块”，本次实验的空闲块均具备分配能力，故无有效碎片产生。

#### （2）分配成功率（100%）
- 数据含义：12次分配请求全部成功，无因内存不足或碎片过多导致的分配失败。
- 原因分析：一方面，总空闲内存（36+48+41+349=474 KB）仍充足；另一方面，空闲块大小均能满足所有历史分配请求的尺寸需求，未出现“总空闲内存充足但无连续块可用”的情况。

#### （3）释放失败情况（3次）
- 数据含义：3次释放失败均因“请求释放的段未被分配过”（如进程5的段2、进程4的段0）。
- 说明：模拟中释放操作是随机生成的，未考虑进程的实际分配历史，符合真实系统中“无效释放请求”的场景，验证了程序对非法释放的容错处理能力。

## 三、实验数据说明的核心问题
### 1. 分段内存管理的核心优势得到验证
#### （1）连续分配与逻辑独立性保障
实验中所有段的分配均为连续物理内存块（如进程2的段1、段2分别分配在36 KB和314 KB起始地址，均为连续块），体现了分段管理“按逻辑模块分配连续内存”的设计思想，保障了进程运行时的地址访问效率。

#### （2）空闲块合并机制有效减少碎片
请求4、12、13、20的释放操作后，程序均自动合并相邻空闲块（如请求20将11 KB和37 KB空闲块合并为48 KB），验证了空闲块合并机制的有效性——该机制能避免因频繁释放产生的微小空闲块累积，是缓解外部碎片的关键手段。

### 2. 外部碎片的产生与分配算法的关联性
#### （1）碎片产生的前提条件未满足
本次实验碎片率为0%的核心原因：
- 分配请求大小差异较小（36 KB ~ 109 KB），无极端大小的段请求，减少了“大段分配后残留小空闲块”的概率；
- 最小分配请求（36 KB）与最终空闲块大小（均≥36 KB）匹配，无“无法满足最小请求”的空闲块；
- 释放操作触发的合并机制及时整合了分散空闲块，避免了碎片累积。

#### （2）首次适应算法的表现特征
实验数据表明，首次适应算法在“分配请求大小均匀、操作频率适中”的场景下表现优异：
- 优势：查找效率高，优先利用低地址空闲块，高地址保留大块空闲区（如最终349 KB空闲块），便于后续大段分配；
- 局限性：若长期频繁分配小尺寸段，低地址区域可能形成大量小空闲块（本次实验未出现该情况），需依赖合并机制优化。

### 3. 分段管理的适用场景与局限性启示
#### （1）适用场景验证
实验数据说明，分段内存管理适用于“进程段大小相对均匀、分配/释放频率适中”的场景，能通过连续分配保障访问效率，通过合并机制控制碎片。

#### （2）潜在局限性暗示
本次实验的“零碎片”结果具有特殊性，未模拟极端场景：
- 若分配请求大小差异极大（如5 KB ~ 300 KB），可能产生大量小于最小请求的空闲块，导致碎片率上升；
- 若长期不释放大块内存，可能出现“总空闲内存充足但无连续块满足大段请求”的情况（即外部碎片的核心问题），需通过内存紧凑或段页式管理优化。

## 四、实验结论
1. 修正后的模拟程序准确实现了分段内存管理的核心功能，内存分配、释放及空闲块合并逻辑正确，实验数据真实反映了动态内存操作下的内存状态演变。
2. 分段管理的“连续分配+空闲块合并”机制能有效控制外部碎片，在合理的请求模式下可实现零碎片运行，验证了该管理方式的可行性。
3. 外部碎片的产生与分配请求大小分布、操作频率密切相关，首次适应算法在均匀请求场景下表现最优，但需警惕极端场景下的碎片累积问题。
4. 实验结果为理解分段内存管理的优缺点提供了数据支撑：其优势在于逻辑独立性强、访问效率高，局限性在于对请求模式敏感，易产生外部碎片，需结合内存紧凑或段页式混合管理方案优化。


# 实验展示的数据
内存初始化完成，总大小：1024 KB

【请求1】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：1024 KB | 状态：空闲
==================================================

【请求2】分配 - 进程3 | 段1 | 大小36 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：36 KB | 大小：988 KB | 状态：空闲
==================================================

【请求3】分配 - 进程2 | 段1 | 大小91 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求4】释放 - 进程3 | 段1
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求5】释放 - 进程4 | 段0
释放失败：未找到进程4的段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求6】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：897 KB | 状态：空闲
==================================================

【请求7】分配 - 进程5 | 段0 | 大小48 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：849 KB | 状态：空闲
==================================================

【请求8】分配 - 进程4 | 段0 | 大小37 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：812 KB | 状态：空闲
==================================================

【请求9】分配 - 进程5 | 段0 | 大小102 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：710 KB | 状态：空闲
==================================================

【请求10】释放 - 进程5 | 段2
释放失败：未找到进程5的段2
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：710 KB | 状态：空闲
==================================================

【请求11】分配 - 进程2 | 段2 | 大小108 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求12】释放 - 进程5 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：已分配 | 进程ID：5 | 段ID：0
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求13】释放 - 进程5 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：602 KB | 状态：空闲
==================================================

【请求14】分配 - 进程3 | 段0 | 大小109 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：102 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：493 KB | 状态：空闲
==================================================

【请求15】分配 - 进程3 | 段1 | 大小61 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：493 KB | 状态：空闲
==================================================

【请求16】分配 - 进程2 | 段2 | 大小85 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：408 KB | 状态：空闲
==================================================

【请求17】分配 - 进程4 | 段2 | 大小59 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：48 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求18】分配 - 进程4 | 段1 | 大小37 KB
分配成功！
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：11 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求19】释放 - 进程5 | 段0
释放失败：未找到进程5的段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：11 KB | 状态：空闲
起始地址：175 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：0
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

【请求20】释放 - 进程4 | 段0
释放操作完成
==================== 内存布局 ====================
起始地址：0 KB | 大小：36 KB | 状态：空闲
起始地址：36 KB | 大小：91 KB | 状态：已分配 | 进程ID：2 | 段ID：1
起始地址：127 KB | 大小：37 KB | 状态：已分配 | 进程ID：4 | 段ID：1
起始地址：164 KB | 大小：48 KB | 状态：空闲
起始地址：212 KB | 大小：61 KB | 状态：已分配 | 进程ID：3 | 段ID：1
起始地址：273 KB | 大小：41 KB | 状态：空闲
起始地址：314 KB | 大小：108 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：422 KB | 大小：109 KB | 状态：已分配 | 进程ID：3 | 段ID：0
起始地址：531 KB | 大小：85 KB | 状态：已分配 | 进程ID：2 | 段ID：2
起始地址：616 KB | 大小：59 KB | 状态：已分配 | 进程ID：4 | 段ID：2
起始地址：675 KB | 大小：349 KB | 状态：空闲
==================================================

==================== 模拟结果分析 ====================
总内存大小：1024 KB
外部碎片率：0%
======================================================



# 实验代码

#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <algorithm>

using namespace std;

// 内存块结构体
struct Block {
    int start;
    int size;
    int process_id;
    int segment_id;
};

vector<Block> memory;
const int MEMORY_SIZE = 1024;
const int NUM_REQUESTS = 20;

// 初始化内存
void initialize_memory() {
    memory.clear();
    memory.push_back({0, MEMORY_SIZE, -1, -1});
    cout << "内存初始化完成，总大小：" << MEMORY_SIZE << " KB\n" << endl;
}
// 内存分配（首次适应算法）- 修正版
bool allocate(int process_id, int segment_id, int size) {
    for (int i = 0; i < memory.size(); i++) {
        // 直接使用索引访问，而不是创建引用
        if (memory[i].process_id == -1 && memory[i].size >= size) {
            // 先保存要分配的块的起始地址，因为后面可能会插入新块
            int start_address = memory[i].start;

            // 如果空闲块大于需求，拆分
            if (memory[i].size > size) {
                // 在当前块后面插入一个新的空闲块
                memory.insert(memory.begin() + i + 1,
                    {start_address + size, memory[i].size - size, -1, -1});
            }

            // 关键修正：通过索引重新访问并修改块，而不是使用引用
            memory[i].size = size;
            memory[i].process_id = process_id;
            memory[i].segment_id = segment_id;

            return true;
        }
    }
    return false; // 分配失败
}

// 合并相邻空闲块
void merge_free_blocks() {
    for (int i = 0; i < (int)memory.size() - 1; ) {
        if (memory[i].process_id == -1 && memory[i+1].process_id == -1) {
            memory[i].size += memory[i+1].size;
            memory.erase(memory.begin() + i + 1);
        } else {
            i++;
        }
    }
}

// 释放内存块
void deallocate(int process_id, int segment_id) {
    for (int i = 0; i < memory.size(); i++) {
        Block &block = memory[i];

        if (block.process_id == process_id && block.segment_id == segment_id) {
            block.process_id = -1;
            block.segment_id = -1;

            // 合并空闲块
            merge_free_blocks();
            return;
        }
    }

    cout << "释放失败：未找到进程" << process_id << "的段" << segment_id << "\n";
}

// 计算外部碎片率
double calculate_external_fragmentation(const vector<int>& allocation_sizes) {
    if (allocation_sizes.empty()) return 0.0;

    int smallest_request = *min_element(allocation_sizes.begin(), allocation_sizes.end());
    int fragmented_memory = 0;

    for (const auto& block : memory) {
        if (block.process_id == -1 && block.size < smallest_request) {
            fragmented_memory += block.size;
        }
    }

    return (double)fragmented_memory / MEMORY_SIZE * 100.0;
}

// 打印内存布局
void print_memory_layout() {
    cout << "==================== 内存布局 ====================\n";
    for (const auto& block : memory) {
        cout << "起始地址：" << block.start << " KB | 大小：" << block.size << " KB | ";
        if (block.process_id == -1) {
            cout << "状态：空闲\n";
        } else {
            cout << "状态：已分配 | 进程ID：" << block.process_id
                 << " | 段ID：" << block.segment_id << "\n";
        }
    }
    cout << "==================================================\n\n";
}

int main() {
    srand(time(0));
    initialize_memory();

    vector<int> allocation_sizes;

    for (int i = 0; i < NUM_REQUESTS; ++i) {
        int process_id = rand() % 5 + 1;
        int segment_id = rand() % 3;
        int size = rand() % 100 + 10;

        allocation_sizes.push_back(size);

        if (rand() % 10 < 7) {
            cout << "【请求" << i+1 << "】分配 - 进程" << process_id
                 << " | 段" << segment_id << " | 大小" << size << " KB\n";

            if (allocate(process_id, segment_id, size)) {
                cout << "分配成功！\n";
            } else {
                cout << "分配失败！无足够大的空闲块\n";
            }
        } else {
            cout << "【请求" << i+1 << "】释放 - 进程" << process_id
                 << " | 段" << segment_id << "\n";

            deallocate(process_id, segment_id);
            cout << "释放操作完成\n";
        }

        print_memory_layout();
    }

    double fragmentation_rate = calculate_external_fragmentation(allocation_sizes);
    cout << "==================== 模拟结果分析 ====================\n";
    cout << "总内存大小：" << MEMORY_SIZE << " KB\n";
    cout << "外部碎片率：" << fragmentation_rate << "%\n";
    cout << "======================================================\n";

    return 0;
}



